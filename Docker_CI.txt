도커를 사용하는 이유
다양한 OS의 버전이나 환경으로인해 원하는 프로그램을 installer를 통해서 다운로드할 때 오류가 자주 발생함
=> 도커를 사용하면 바로 오류 없이 다운 받을 수 있음

도커란?
컨테이너를 사용하여 응용프로그램을 더 쉽게 만들고 배포하고 실행할 수 있도록 설계된 도구이며 컨테이너 기반의 오픈소스
가상화 플랫폼 생태계
=> 말그대로 원하는 프로그램들을 컨테이너로 추상화해서 프로그램을 손쉽게 이동 배포 관리해주는 것

도커 이미지는 프로그램을 실행하는데 필요한 설정이나 종속성을 갖고 있는 것
도커 이미지를 이용해서 컨테이너를 생성함 (도커 컨테이너 == 도커 이미지의 인스턴스)
이미지 => 컨테이너 => 컨테이너를 이용해서 프로그램을 실행함



이미지 파일안에는 시작시 실행 될 명령어 + 파일 스냅샷이 들어있음
docker run 이미지 ls
=> 파일 스냅샷이 컨테이너의 하드디스크로 들어오고 시작시 실행 될 명령어가 실행중인 프로세스에 들어가서 명령을 수행함

docker ps

생명주기 ~ kill전까지(강의록 참고)
-a 옵션은 앞부분만 써도 가능
docker start -a id 일부

stop / kill
stop은 gracefully하게 중지
kill은 바로 중지

docker system prune
현재 사용하지 않는 도커 삭제

실행중인 컨테이너에 명령어 전달
docker exec <컨테이너 명> <명령어>

-it 옵션
=> exec로 컨테이너 안으로 들어가서 추가 명령어를 작성할 때 계속해서 명령어를 사용할 수 있게 해주는 옵션
interactive terminal

-it를 붙여주지 않으면 들어갔다가 바로 나와버림 -> 꼭 -it 옵션을 써줄것

실행중인 컨테이너에 명령을 하기 위해서 그러면 위 처럼 귀찮은 방법을 계속 써야하는가?
=> NO!
sh명령어를 통해서 아예 해당 컨테이너 안으로 들어가서 그 안에서 명령어만 계속 작성할 수 있음
docker run -it <이미지 이름> sh => /# 으로 바뀌면서 해당 컨테이너 안으로 들어감
나올때는 ctrl + D

기존에는 도커허브에 있던 이미지만을 사용해 왔음
=> Dockerfile를 작성해서 직접 이미지를 만들 수 있음
Dockerfile이란 Docker image를 만들기 위한 설정 파일임 => 컨테이너가 어떻게 행동해야 하는 지에 대한 설정들을 정의해줌

Dockerfile를 만드는 순서
1. 베이스 이미지를 명시해준다(파일 스냅샷)
2. 추가적으로 필요한 파일을 다운 받기 위한 몇가지 명령어를 명시해준다(파일 스냅샷)
3. 컨테이너 시작시 실행 될 명령어를 명시해준다(시작시 실행 될 명령어)

FROM : 베이직 이미지 레이어
RUN : 도커이미지가 생성되기 전에 수행할 쉘 명령어 => 필요한 파일들을 다운로드 받는데 사용
CMD : 컨테이너가 시작되었을 때 실행할 실행 파일 또는 쉘 스크립트(Dockerfile에서 1번만 사용가능)

docker build . or docker build ./
=> dockerfile을 docker client로 전달하는 방법 

결론
베이스 이미지에서 다른 종속성이나 새로운 커맨드를 추가할 때는 임시 컨테이너를 만든 후 그 컨테이너를 토대로 새로운 이미지를 만든다
그리고 그 임시 컨테이너는 지워준다
이미지 -> 임시 컨테이너(새로운 명령어 + 새로운 파일 스냅샷) -> 새로운 이미지

내가 설정한 dockerfile에 직접 커스텀한 이름지어주기(-t 옵션)
docker build -t ghlim909/hello:latest ./ 

===================================================================
4~6
---------------------------------------------------------------------------------
4강
nodejs app 만들기
도커 파일 만들기
```
FROM node:10

RUN npm install

CMD ["node", "server.js"]
```
여기에서는 package.json이 없다고 에러가 발생함
=> npm install에서 dependencies를 받아와야하는데 해당 스냅샷 안에는 package.json이 없음
=> COPY를 통해서 복사해 와야함

COPY package.json(로컬에 있는 이 파일을) ./(도커 컨테이너의 이 지정된 장소에 복사해주기)
== COPY 복사할 파일 경로 컨테이너내에서 파일이 복사될 경로

그리고 실행을 하면? => server.js가 없다고 에러가 발생함 : 원인은 위와 같음
=> COPY를 전부 복사함
=> COPY ./ ./
```
FROM node:10

COPY ./ ./

RUN npm install

CMD ["node", "server.js"]
```
=> docker build -t ghlim909/nodejs ./ 
=> docker run ghlim909/nodejs:latest

=> 또 에러가 발생함 포트때문

server.js에 PORT를 8080으로 설정했지만 localhost PORT에서는 접근할 방법이 없다...
=> docker run -p 5000:8080 ghlim909/nodejs
=> docker run -p [localhost의 PORT]:[container의 PORT] [이미지 이름]

WORKDIR 설정하기
WORKDIR을 설정하지 않으면 Dockerfile의 COPY를 통해 복사되는 파일들이 컨테이너의 root 디렉토리에 복사된다
이렇게 되면 단점은
=> 1. root 디렉토리가 매우 더러워짐
=> 2. 만약에 로컬에 있는 폴더명이 root디렉토리의 기본설정 폴더명과 같으면 덮어 써버림 ;;
=> WORKDIR를 설정해서 COPY 되는 파일들을 특정 디렉토리안에 넣어버리면된다
```
FROM node:10

WORKDIR /usr/src/app

COPY ./ ./

RUN npm install

CMD ["node", "server.js"]
```
=> WORKDIR /usr/src/app 를 통해 /usr/src/app안에 COPY된 파일들을 넣는다
=> docker run -it ghlim909/nodejs sh 
=> 를 통해 해당 컨테이너 내부로 들어가면 바로 로컬에서 COPY된 목록들부터 볼 수 있다.

-d 옵션
=> 컨테이너를 백그라운드로 실행하는 옵션

그렇다면 만약에 소스코드가 바뀌었을 경우에 이를 웹사이트에 반영하기 위해서는?
=> 다시 도커파일로 도커이미지를 빌드 => 도커 이미지로 컨테이너를 생성 후 앱 실행
=> 위의 과정을 반복해야함
=> why?
=> COPY ./ ./를 사용했기 때문에 소스가 바뀐 부분은 server.js뿐이지만 모든 node module까지 다시 다운 받아야함
=> 그리고 소스 하나 변경했을 뿐이지만 이미지를 다시 생성하고 다시 컨테이너를 실행시켜줘야함
=> 매우 비효율적임

먼저
```
FROM node:10

WORKDIR /usr/src/app

COPY package.json ./		=> package.json을 맨 처음에는 먼저 복사를 하고 npm install 해놓고 이후에 소스코드가 변경되면 이 부분은 캐시 이용

RUN npm install

COPY ./ ./

CMD ["node", "server.js"]
``` 
-----------공지-----------

맥에서

-v $(pwd):/usr/src/app

윈도우에서

-v %cd%:/usr/src/app
---------------------------

VOLUME 옵션

[그림 넣기]
COPY는 로컬의 파일을 컨테이너에 복사하지만 
VOLUME은 컨테이너가 로컬의 파일을 참조함

VOLUME을 사용해서 파일목록을 mapping하면 이후에 소스코드가 바뀌어도 이미지를 다시 빌드하지 않고 컨테이너만  stop했다가 run해서 변경된 코드 적용 가능
=> docker run -p 5000:8080 -v /usr/src/app/node_modules -v %cd%:/usr/src/app [이미지 아이디]
=> docker run -p [local PORT]:[container PORT] -v [참조하지 않을 특정 WORKDIR 파일] -v [참조할 local dir]:[컨테이너의 WORKDIR] [이미지 아이디]
-v /usr/src/app/node_modules => local에는 node_modules가 없기 때문에 WORKDIR의 node_modules는 local을 참조하지 않겠다.
-v %cd%:/usr/src/app => %cd%는 참조할 local의 디렉토리 주소, /usr/src/app은 컨테이너의 WORKDIR 주소

---------------------------------------------------------------------------------

docker compose
다중 컨테이너 도커 애플리케이션을 정의하고 실행하기 위한 도구

간단한 앱만들기 with redis
 
redis?
== remote dictionary server 는 메모리 기반의 키-값 구조
데이터 관리시스템, 모든 데이터를 메모리에 저장하고 빠르게 조회할 수 있는 비관계형 데이터베이스임(NoSql)

server.js
Dockerfile 작성

nodejs + redis 로 만든 앱을 docker로 올리면
먼저 redis 서버가 작동하고 있어야함(전제)
이후에 nodejs앱 + redis 클라이언트가 한 컨테이너에서 작동

하지만 에러가 발생한다.
=> 이유는 컨테이너 사이에서 아무런 설정없이 통신할 수 없기 때문에
=> nodejs 앱에서 redis 서버에 접근 할 수 없다.

[그림추가]
 
컨테이너 사이에서 통신 설정을 해주기 위해서는 (멀티 컨테이너 상황)
docker-compose파일을 작성한다.

docker-compose.yml 작성
[그림추가]

```
version: "3"
services:
  redis-server:
    image: "redis"
  node-app:
    build: .
    ports:
      - "5000:8080"
```

docker-compose up 
=> 실행
docker-compose up -d
=> 백그라운드로 실행
docker-compose up --build
=> 다시 build 하고 실행
docker-compose up -d --build
=> 백그라운드로 다시 build하고 실행


docker-compose down 
=> 컨테이너 멈추기

docker-compose down
=> 멈추기

---------------------------------------------------------------------------------
간단한 어플을 실제로 배포하기(6강)
=> 개발환경에서 간단한 리액트 앱 개발
(7강) => 리액트 앱 테스트 & 배포

[그림추가]

리액트 설치
npx create-react-app ./

리액트 실행
npm run start
리액트 테스트
npm run test
리액트 배포
npm run build

react의 dockerfile 만들기

```
FROM node:alpine

WORKDIR /usr/src/app

COPY package.json ./

RUN npm install

COPY ./ ./

CMD ["npm", "run", "start"]
```

Dockerfile.dev가 작성된 이후에
docker build ./ 하면 Dockerfile을 찾지 못했다는 에러가 발생
=> docker build -f Dockerfile.dev ./
=> -f옵션으로 직접 Dockerfile이름을 지정해줌

node_modules 삭제 => 강의록 참고

포트 설정 + -it 옵션을 한 후 에 run!
----------------------------------------------------
[react 앱을 docker로 실행하기]
위에서 만든 react Dockerfile.dev를 가지고 이미지 만들기
=> docker build -f Dockerfile.dev -t ghlim909/docker-react-app

만든 이미지로 컨테이너 만들기
=> docker run -it -p 3000:3000 ghlim909/docker-react-app
----------------------------------------------------

VOLUME 옵션
소스코드에서 변경이 되었을 경우 다시 이미지를 빌드하지 않고 VOLUME를 통해 변경한 부분을 적용하기

docker run -it -p 3000:3000 -v /usr/src/app/node_modules -v $(pwd):/usr/src/app markcha/react

해당 디렉토리가 없거나 관리자 권한이 필요할 때 
```
FROM node:alpine

RUN cd home \
        && mkdir ret

RUN chmod -R 777 /home/ret

WORKDIR home/ret

COPY package.json .\

RUN npm install

COPY ./ ./

CMD ["npm", "run", "start"]
```

위의 run 실행 명령이 너무 길기 때문에 좀 더 간단한 방법 사용해보기
=> docker-compose.yml 이용

```
version: "3"
services:
  react:
    build:			=> Dockerfile를 통해서 이미지를 만들고 빌드하는 경우에 작성
      context: .		=> Dockerfile이 있는 위치
      dockerfile: Dockerfile.dev
    ports:
      - "3000:3000"
    volumes:
      - /usr/src/app/node_modules	=> node_modules는 참조할 필요 없음을 알림 
      - ./:/usr/src/app		=> -v $(pwd):/usr/src/app 과 같은 역할
    stdin_open: true
```

docker-compose 작성 후에
=> docker-compose up 으로 실행 

react앱을 docker 에서 테스트하기
npm run test를 docker 내부에서 하는법
=> docker run -it -p 3000:3000 ghlim909/docker-react-app npm run test






